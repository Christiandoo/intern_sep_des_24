generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model user {
  id               String          @id @db.VarChar(191)
  name             String?         @db.VarChar(191)
  username         String?         @unique
  email            String?         @unique
  emailVerified    DateTime?
  image            String?         @db.VarChar(191)
  createdAt        DateTime        @default(dbgenerated("CURRENT_TIMESTAMP(3)"))
  updatedAt        DateTime
  resetToken       String?         @db.VarChar(191)
  resetTokenExpiry DateTime?
  passwordHash     String          @db.VarChar(191)

  account          account?
  assignment       assignment[]
  authenticator    authenticator[]
  session          session[]

  roles            role[]          @relation("UserRoles")
}

model role {
  id       String   @id
  name     String   @unique

  users    user[]   @relation("UserRoles")
  projects project[]

  @@map("roles")
}

model project {
  id          String         @id @db.VarChar(191)
  name        String         @db.VarChar(191)
  workOrder   String?        @db.VarChar(191)
  createdAt   DateTime       @default(dbgenerated("CURRENT_TIMESTAMP(3)"))
  updatedAt   DateTime
  start       DateTime
  end         DateTime
  description String?        @db.VarChar(191)
  status      project_status @default(PENDING)

  roleId      String
  role        role           @relation(fields: [roleId], references: [id], onDelete: Cascade)

  assignment  assignment[]
}

model assignment {
  id          String            @id @db.VarChar(191)
  title       String            @db.VarChar(191)
  status      assignment_status @default(PENDING)
  createdAt   DateTime          @default(dbgenerated("CURRENT_TIMESTAMP(3)"))
  description String?           @db.VarChar(191)
  start       DateTime?
  end         DateTime?
  updatedAt   DateTime

  projectId   String
  userId      String

  project     project           @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user        user              @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model account {
  id                       String   @id @db.VarChar(191)
  userId                   String   @unique @db.VarChar(191)
  type                     String   @db.VarChar(191)
  provider                 String   @db.VarChar(191)
  providerAccountId        String   @db.VarChar(191)
  refresh_token            String?
  access_token             String?
  expires_at               Int?
  token_type               String?  @db.VarChar(191)
  scope                    String?  @db.VarChar(191)
  id_token                 String?
  session_state            String?  @db.VarChar(191)
  refresh_token_expires_in Int?
  createdAt                DateTime @default(dbgenerated("CURRENT_TIMESTAMP(3)"))
  updatedAt                DateTime

  user                     user     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model session {
  id           String   @id @db.VarChar(191)
  sessionToken String   @unique @db.VarChar(191)
  userId       String   @db.VarChar(191)
  expires      DateTime
  createdAt    DateTime @default(dbgenerated("CURRENT_TIMESTAMP(3)"))
  updatedAt    DateTime

  user         user     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model authenticator {
  credentialID         String  @db.VarChar(191)
  userId               String  @db.VarChar(191)
  providerAccountId    String  @db.VarChar(191)
  credentialPublicKey  String  @db.VarChar(191)
  counter              Int
  credentialDeviceType String  @db.VarChar(191)
  credentialBackedUp   Boolean
  transports           String? @db.VarChar(191)

  user                 user    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
}

model verificationtoken {
  identifier String   @db.VarChar(191)
  token      String   @db.VarChar(191)
  expires    DateTime

  @@id([identifier, token])
}

enum assignment_status {
  PENDING
  ACTIVE
  IN_PROGRESS
  FINISH
}

enum project_status {
  PENDING
  ACTIVE
  IN_PROGRESS
  FINISH
}
